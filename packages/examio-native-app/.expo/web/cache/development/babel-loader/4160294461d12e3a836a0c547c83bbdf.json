{"ast":null,"code":"import Dimensions from \"react-native-web/dist/exports/Dimensions\";\nimport I18nManager from \"react-native-web/dist/exports/I18nManager\";\nimport getSceneIndicesForInterpolationInputRange from \"../../utils/getSceneIndicesForInterpolationInputRange\";\n\nfunction hasHeader(scene) {\n  if (!scene) {\n    return true;\n  }\n\n  var _scene$descriptor$opt = scene.descriptor.options,\n      header = _scene$descriptor$opt.header,\n      headerShown = _scene$descriptor$opt.headerShown;\n  return header !== null && headerShown !== false;\n}\n\nvar crossFadeInterpolation = function crossFadeInterpolation(scenes, first, index, last) {\n  return {\n    inputRange: [first, first + 0.001, index - 0.9, index - 0.2, index, last - 0.001, last],\n    outputRange: [0, hasHeader(scenes[first]) ? 0 : 1, hasHeader(scenes[first]) ? 0 : 1, hasHeader(scenes[first]) ? 0.3 : 1, hasHeader(scenes[index]) ? 1 : 0, hasHeader(scenes[last]) ? 0 : 1, 0],\n    extrapolate: 'clamp'\n  };\n};\n\nfunction isGoingBack(scenes) {\n  var lastSceneIndexInScenes = scenes.length - 1;\n  return !scenes[lastSceneIndexInScenes].isActive;\n}\n\nfunction forLayout(props) {\n  var layout = props.layout,\n      position = props.position,\n      scene = props.scene,\n      scenes = props.scenes,\n      mode = props.mode;\n\n  if (mode !== 'float') {\n    return {};\n  }\n\n  var isBack = isGoingBack(scenes);\n  var interpolate = getSceneIndicesForInterpolationInputRange(props);\n  if (!interpolate) return {};\n  var first = interpolate.first,\n      last = interpolate.last;\n  var index = scene.index;\n  var width = layout.initWidth || Dimensions.get('window').width;\n\n  if (isBack && !hasHeader(scenes[index]) && !hasHeader(scenes[last]) || !isBack && !hasHeader(scenes[first]) && !hasHeader(scenes[index])) {\n    return {\n      transform: [{\n        translateX: width\n      }]\n    };\n  }\n\n  var rtlMult = I18nManager.isRTL ? -1 : 1;\n  var translateX = position.interpolate({\n    inputRange: [first, index, last],\n    outputRange: [rtlMult * (hasHeader(scenes[first]) ? 0 : width), rtlMult * (hasHeader(scenes[index]) ? 0 : isBack ? width : -width), rtlMult * (hasHeader(scenes[last]) ? 0 : -width)],\n    extrapolate: 'clamp'\n  });\n  return {\n    transform: [{\n      translateX: translateX\n    }]\n  };\n}\n\nfunction forLeft(props) {\n  var position = props.position,\n      scene = props.scene,\n      scenes = props.scenes;\n  var interpolate = getSceneIndicesForInterpolationInputRange(props);\n  if (!interpolate) return {\n    opacity: 0\n  };\n  var first = interpolate.first,\n      last = interpolate.last;\n  var index = scene.index;\n  return {\n    opacity: position.interpolate(crossFadeInterpolation(scenes, first, index, last))\n  };\n}\n\nfunction forCenter(props) {\n  var position = props.position,\n      scene = props.scene,\n      scenes = props.scenes;\n  var interpolate = getSceneIndicesForInterpolationInputRange(props);\n  if (!interpolate) return {\n    opacity: 0\n  };\n  var first = interpolate.first,\n      last = interpolate.last;\n  var index = scene.index;\n  return {\n    opacity: position.interpolate(crossFadeInterpolation(scenes, first, index, last))\n  };\n}\n\nfunction forRight(props) {\n  var position = props.position,\n      scene = props.scene,\n      scenes = props.scenes;\n  var interpolate = getSceneIndicesForInterpolationInputRange(props);\n  if (!interpolate) return {\n    opacity: 0\n  };\n  var first = interpolate.first,\n      last = interpolate.last;\n  var index = scene.index;\n  return {\n    opacity: position.interpolate(crossFadeInterpolation(scenes, first, index, last))\n  };\n}\n\nfunction forLeftButton(props) {\n  var position = props.position,\n      scene = props.scene,\n      scenes = props.scenes;\n  var interpolate = getSceneIndicesForInterpolationInputRange(props);\n  if (!interpolate) return {\n    opacity: 0\n  };\n  var first = interpolate.first,\n      last = interpolate.last;\n  var index = scene.index;\n  var inputRange = [first, first + 0.001, first + Math.abs(index - first) / 2, index, last - Math.abs(last - index) / 2, last - 0.001, last];\n  var outputRange = [0, hasHeader(scenes[first]) ? 0 : 1, hasHeader(scenes[first]) ? 0.3 : 1, hasHeader(scenes[index]) ? 1 : 0, hasHeader(scenes[last]) ? 0.3 : 1, hasHeader(scenes[last]) ? 0 : 1, 0];\n  return {\n    opacity: position.interpolate({\n      inputRange: inputRange,\n      outputRange: outputRange,\n      extrapolate: 'clamp'\n    })\n  };\n}\n\nvar LEFT_LABEL_OFFSET = Dimensions.get('window').width / 2 - 70 - 25;\n\nfunction forLeftLabel(props) {\n  var position = props.position,\n      scene = props.scene,\n      scenes = props.scenes;\n  var interpolate = getSceneIndicesForInterpolationInputRange(props);\n  if (!interpolate) return {\n    opacity: 0\n  };\n  var first = interpolate.first,\n      last = interpolate.last;\n  var index = scene.index;\n  var offset = LEFT_LABEL_OFFSET;\n  return {\n    opacity: position.interpolate({\n      inputRange: [first, first + 0.001, index - 0.35, index, index + 0.5, last - 0.001, last],\n      outputRange: [0, hasHeader(scenes[first]) ? 0 : 1, hasHeader(scenes[first]) ? 0 : 1, hasHeader(scenes[index]) ? 1 : 0, hasHeader(scenes[last]) ? 0.5 : 1, hasHeader(scenes[last]) ? 0 : 1, 0],\n      extrapolate: 'clamp'\n    }),\n    transform: [{\n      translateX: position.interpolate({\n        inputRange: [first, first + 0.001, index, last - 0.001, last],\n        outputRange: I18nManager.isRTL ? [-offset * 1.5, hasHeader(scenes[first]) ? -offset * 1.5 : 0, 0, hasHeader(scenes[last]) ? offset : 0, offset] : [offset, hasHeader(scenes[first]) ? offset : 0, 0, hasHeader(scenes[last]) ? -offset * 1.5 : 0, -offset * 1.5],\n        extrapolate: 'clamp'\n      })\n    }]\n  };\n}\n\nvar TITLE_OFFSET_IOS = Dimensions.get('window').width / 2 - 70 + 25;\n\nfunction forCenterFromLeft(props) {\n  var position = props.position,\n      scene = props.scene,\n      scenes = props.scenes;\n  var interpolate = getSceneIndicesForInterpolationInputRange(props);\n  if (!interpolate) return {\n    opacity: 0\n  };\n  var first = interpolate.first,\n      last = interpolate.last;\n  var index = scene.index;\n  var offset = TITLE_OFFSET_IOS;\n  return {\n    opacity: position.interpolate({\n      inputRange: [first, first + 0.001, index - 0.5, index, index + 0.7, last - 0.001, last],\n      outputRange: [0, hasHeader(scenes[first]) ? 0 : 1, hasHeader(scenes[first]) ? 0 : 1, hasHeader(scenes[index]) ? 1 : 0, hasHeader(scenes[last]) ? 0 : 1, hasHeader(scenes[last]) ? 0 : 1, 0],\n      extrapolate: 'clamp'\n    }),\n    transform: [{\n      translateX: position.interpolate({\n        inputRange: [first, first + 0.001, index, last - 0.001, last],\n        outputRange: I18nManager.isRTL ? [-offset, hasHeader(scenes[first]) ? -offset : 0, 0, hasHeader(scenes[last]) ? offset : 0, offset] : [offset, hasHeader(scenes[first]) ? offset : 0, 0, hasHeader(scenes[last]) ? -offset : 0, -offset],\n        extrapolate: 'clamp'\n      })\n    }]\n  };\n}\n\nfunction forBackgroundWithFade(props) {\n  var position = props.position,\n      scene = props.scene;\n  var sceneRange = getSceneIndicesForInterpolationInputRange(props);\n  if (!sceneRange) return {\n    opacity: 0\n  };\n  return {\n    opacity: position.interpolate({\n      inputRange: [sceneRange.first, scene.index, sceneRange.last],\n      outputRange: [0, 1, 0],\n      extrapolate: 'clamp'\n    })\n  };\n}\n\nvar VISIBLE = {\n  opacity: 1\n};\nvar HIDDEN = {\n  opacity: 0\n};\n\nfunction forBackgroundWithInactiveHidden(_ref) {\n  var navigation = _ref.navigation,\n      scene = _ref.scene;\n  return navigation.state.index === scene.index ? VISIBLE : HIDDEN;\n}\n\nvar BACKGROUND_OFFSET = Dimensions.get('window').width;\n\nfunction forBackgroundWithTranslation(props) {\n  var position = props.position,\n      scene = props.scene;\n  var interpolate = getSceneIndicesForInterpolationInputRange(props);\n  if (!interpolate) return {\n    opacity: 0\n  };\n  var first = interpolate.first,\n      last = interpolate.last;\n  var index = scene.index;\n  var offset = BACKGROUND_OFFSET;\n  var outputRange = [offset, 0, -offset];\n  return {\n    transform: [{\n      translateX: position.interpolate({\n        inputRange: [first, index, last],\n        outputRange: I18nManager.isRTL ? outputRange.reverse() : outputRange,\n        extrapolate: 'clamp'\n      })\n    }]\n  };\n}\n\nvar forBackground = forBackgroundWithInactiveHidden;\nexport default {\n  forLayout: forLayout,\n  forLeft: forLeft,\n  forLeftButton: forLeftButton,\n  forLeftLabel: forLeftLabel,\n  forCenterFromLeft: forCenterFromLeft,\n  forCenter: forCenter,\n  forRight: forRight,\n  forBackground: forBackground,\n  forBackgroundWithInactiveHidden: forBackgroundWithInactiveHidden,\n  forBackgroundWithFade: forBackgroundWithFade,\n  forBackgroundWithTranslation: forBackgroundWithTranslation\n};","map":{"version":3,"sources":["HeaderStyleInterpolator.tsx"],"names":["header","headerShown","scene","crossFadeInterpolation","inputRange","first","index","last","outputRange","hasHeader","scenes","extrapolate","lastSceneIndexInScenes","layout","position","mode","props","isBack","isGoingBack","interpolate","getSceneIndicesForInterpolationInputRange","width","Dimensions","transform","translateX","rtlMult","I18nManager","opacity","Math","LEFT_LABEL_OFFSET","offset","TITLE_OFFSET_IOS","sceneRange","VISIBLE","HIDDEN","navigation","BACKGROUND_OFFSET","forBackground","forLayout","forLeft","forLeftButton","forLeftLabel","forCenterFromLeft","forCenter","forRight","forBackgroundWithInactiveHidden","forBackgroundWithFade","forBackgroundWithTranslation"],"mappings":"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","sourcesContent":["import { Dimensions, I18nManager } from 'react-native';\nimport getSceneIndicesForInterpolationInputRange from '../../utils/getSceneIndicesForInterpolationInputRange';\nimport { Scene, SceneInterpolatorProps } from '../../types';\n\nfunction hasHeader(scene: Scene) {\n  if (!scene) {\n    return true;\n  }\n  const { header, headerShown } = scene.descriptor.options;\n\n  return header !== null && headerShown !== false;\n}\n\nconst crossFadeInterpolation = (\n  scenes: Scene[],\n  first: number,\n  index: number,\n  last: number\n): { inputRange: number[]; outputRange: number[]; extrapolate: 'clamp' } => ({\n  inputRange: [\n    first,\n    first + 0.001,\n    index - 0.9,\n    index - 0.2,\n    index,\n    last - 0.001,\n    last,\n  ],\n  outputRange: [\n    0,\n    hasHeader(scenes[first]) ? 0 : 1,\n    hasHeader(scenes[first]) ? 0 : 1,\n    hasHeader(scenes[first]) ? 0.3 : 1,\n    hasHeader(scenes[index]) ? 1 : 0,\n    hasHeader(scenes[last]) ? 0 : 1,\n    0,\n  ],\n  extrapolate: 'clamp',\n});\n\n/**\n * Utilities that build the style for the navigation header.\n *\n * +-------------+-------------+-------------+\n * |             |             |             |\n * |    Left     |   Title     |   Right     |\n * |  Component  |  Component  | Component   |\n * |             |             |             |\n * +-------------+-------------+-------------+\n */\n\nfunction isGoingBack(scenes: Scene[]) {\n  const lastSceneIndexInScenes = scenes.length - 1;\n  return !scenes[lastSceneIndexInScenes].isActive;\n}\n\nfunction forLayout(props: SceneInterpolatorProps) {\n  const { layout, position, scene, scenes, mode } = props;\n  if (mode !== 'float') {\n    return {};\n  }\n  const isBack = isGoingBack(scenes);\n\n  const interpolate = getSceneIndicesForInterpolationInputRange(props);\n  if (!interpolate) return {};\n\n  const { first, last } = interpolate;\n  const index = scene.index;\n\n  // We really shouldn't render the scene at all until we know the width of the\n  // stack. That said, in every case that I have ever seen, this has just been\n  // the full width of the window. This won't continue to be true if we support\n  // layouts like iPad master-detail. For now, in order to solve\n  // https://github.com/react-navigation/react-navigation/issues/4264, I have\n  // opted for the heuristic that we will use the window width until we have\n  // measured (and they will usually be the same).\n  const width = layout.initWidth || Dimensions.get('window').width;\n\n  // Make sure the header stays hidden when transitioning between 2 screens\n  // with no header.\n  if (\n    (isBack && !hasHeader(scenes[index]) && !hasHeader(scenes[last])) ||\n    (!isBack && !hasHeader(scenes[first]) && !hasHeader(scenes[index]))\n  ) {\n    return {\n      transform: [{ translateX: width }],\n    };\n  }\n\n  const rtlMult = I18nManager.isRTL ? -1 : 1;\n  const translateX = position.interpolate({\n    inputRange: [first, index, last],\n    outputRange: [\n      rtlMult * (hasHeader(scenes[first]) ? 0 : width),\n      rtlMult * (hasHeader(scenes[index]) ? 0 : isBack ? width : -width),\n      rtlMult * (hasHeader(scenes[last]) ? 0 : -width),\n    ],\n    extrapolate: 'clamp',\n  });\n\n  return {\n    transform: [{ translateX }],\n  };\n}\n\nfunction forLeft(props: SceneInterpolatorProps) {\n  const { position, scene, scenes } = props;\n  const interpolate = getSceneIndicesForInterpolationInputRange(props);\n\n  if (!interpolate) return { opacity: 0 };\n\n  const { first, last } = interpolate;\n  const index = scene.index;\n\n  return {\n    opacity: position.interpolate(\n      crossFadeInterpolation(scenes, first, index, last)\n    ),\n  };\n}\n\nfunction forCenter(props: SceneInterpolatorProps) {\n  const { position, scene, scenes } = props;\n  const interpolate = getSceneIndicesForInterpolationInputRange(props);\n\n  if (!interpolate) return { opacity: 0 };\n\n  const { first, last } = interpolate;\n  const index = scene.index;\n\n  return {\n    opacity: position.interpolate(\n      crossFadeInterpolation(scenes, first, index, last)\n    ),\n  };\n}\n\nfunction forRight(props: SceneInterpolatorProps) {\n  const { position, scene, scenes } = props;\n  const interpolate = getSceneIndicesForInterpolationInputRange(props);\n\n  if (!interpolate) return { opacity: 0 };\n  const { first, last } = interpolate;\n  const index = scene.index;\n\n  return {\n    opacity: position.interpolate(\n      crossFadeInterpolation(scenes, first, index, last)\n    ),\n  };\n}\n\n/**\n * iOS UINavigationController style interpolators\n */\n\nfunction forLeftButton(props: SceneInterpolatorProps) {\n  const { position, scene, scenes } = props;\n  const interpolate = getSceneIndicesForInterpolationInputRange(props);\n\n  if (!interpolate) return { opacity: 0 };\n\n  const { first, last } = interpolate;\n  const index = scene.index;\n\n  // The gist of what we're doing here is animating the left button _normally_ (fast fade)\n  // when both scenes in transition have headers. When the current, next, or previous scene _don't_\n  // have a header, we don't fade the button, and only set it's opacity to 0 at the last moment\n  // of the transition.\n  const inputRange = [\n    first,\n    first + 0.001,\n    first + Math.abs(index - first) / 2,\n    index,\n    last - Math.abs(last - index) / 2,\n    last - 0.001,\n    last,\n  ];\n  const outputRange = [\n    0,\n    hasHeader(scenes[first]) ? 0 : 1,\n    hasHeader(scenes[first]) ? 0.3 : 1,\n    hasHeader(scenes[index]) ? 1 : 0,\n    hasHeader(scenes[last]) ? 0.3 : 1,\n    hasHeader(scenes[last]) ? 0 : 1,\n    0,\n  ];\n\n  return {\n    opacity: position.interpolate({\n      inputRange,\n      outputRange,\n      extrapolate: 'clamp',\n    }),\n  };\n}\n\n/*\n * NOTE: this offset calculation is an approximation that gives us\n * decent results in many cases, but it is ultimately a poor substitute\n * for text measurement. See the comment on title for more information.\n *\n * - 70 is the width of the left button area.\n * - 25 is the width of the left button icon (to account for label offset)\n */\nconst LEFT_LABEL_OFFSET = Dimensions.get('window').width / 2 - 70 - 25;\n\nfunction forLeftLabel(props: SceneInterpolatorProps) {\n  const { position, scene, scenes } = props;\n  const interpolate = getSceneIndicesForInterpolationInputRange(props);\n\n  if (!interpolate) return { opacity: 0 };\n\n  const { first, last } = interpolate;\n  const index = scene.index;\n\n  const offset = LEFT_LABEL_OFFSET;\n\n  // Similarly to the animation of the left label, when animating to or from a scene without\n  // a header, we keep the label at full opacity and in the same position for as long as possible.\n  return {\n    // For now we fade out the label before fading in the title, so the\n    // differences between the label and title position can be hopefully not so\n    // noticable to the user\n    opacity: position.interpolate({\n      inputRange: [\n        first,\n        first + 0.001,\n        index - 0.35,\n        index,\n        index + 0.5,\n        last - 0.001,\n        last,\n      ],\n      outputRange: [\n        0,\n        hasHeader(scenes[first]) ? 0 : 1,\n        hasHeader(scenes[first]) ? 0 : 1,\n        hasHeader(scenes[index]) ? 1 : 0,\n        hasHeader(scenes[last]) ? 0.5 : 1,\n        hasHeader(scenes[last]) ? 0 : 1,\n        0,\n      ],\n      extrapolate: 'clamp',\n    }),\n    transform: [\n      {\n        translateX: position.interpolate({\n          inputRange: [first, first + 0.001, index, last - 0.001, last],\n          outputRange: I18nManager.isRTL\n            ? [\n                -offset * 1.5,\n                hasHeader(scenes[first]) ? -offset * 1.5 : 0,\n                0,\n                hasHeader(scenes[last]) ? offset : 0,\n                offset,\n              ]\n            : [\n                offset,\n                hasHeader(scenes[first]) ? offset : 0,\n                0,\n                hasHeader(scenes[last]) ? -offset * 1.5 : 0,\n                -offset * 1.5,\n              ],\n          extrapolate: 'clamp',\n        }),\n      },\n    ],\n  };\n}\n\n/*\n * NOTE: this offset calculation is a an approximation that gives us\n * decent results in many cases, but it is ultimately a poor substitute\n * for text measurement. We want the back button label to transition\n * smoothly into the title text and to do this we need to understand\n * where the title is positioned within the title container (since it is\n * centered).\n *\n * - 70 is the width of the left button area.\n * - 25 is the width of the left button icon (to account for label offset)\n */\nconst TITLE_OFFSET_IOS = Dimensions.get('window').width / 2 - 70 + 25;\n\nfunction forCenterFromLeft(props: SceneInterpolatorProps) {\n  const { position, scene, scenes } = props;\n  const interpolate = getSceneIndicesForInterpolationInputRange(props);\n\n  if (!interpolate) return { opacity: 0 };\n\n  const { first, last } = interpolate;\n  const index = scene.index;\n  const offset = TITLE_OFFSET_IOS;\n\n  return {\n    opacity: position.interpolate({\n      inputRange: [\n        first,\n        first + 0.001,\n        index - 0.5,\n        index,\n        index + 0.7,\n        last - 0.001,\n        last,\n      ],\n      outputRange: [\n        0,\n        hasHeader(scenes[first]) ? 0 : 1,\n        hasHeader(scenes[first]) ? 0 : 1,\n        hasHeader(scenes[index]) ? 1 : 0,\n        hasHeader(scenes[last]) ? 0 : 1,\n        hasHeader(scenes[last]) ? 0 : 1,\n        0,\n      ],\n      extrapolate: 'clamp',\n    }),\n    transform: [\n      {\n        translateX: position.interpolate({\n          inputRange: [first, first + 0.001, index, last - 0.001, last],\n          outputRange: I18nManager.isRTL\n            ? [\n                -offset,\n                hasHeader(scenes[first]) ? -offset : 0,\n                0,\n                hasHeader(scenes[last]) ? offset : 0,\n                offset,\n              ]\n            : [\n                offset,\n                hasHeader(scenes[first]) ? offset : 0,\n                0,\n                hasHeader(scenes[last]) ? -offset : 0,\n                -offset,\n              ],\n          extrapolate: 'clamp',\n        }),\n      },\n    ],\n  };\n}\n\n// Fade in background of header while transitioning\nfunction forBackgroundWithFade(props: SceneInterpolatorProps) {\n  const { position, scene } = props;\n  const sceneRange = getSceneIndicesForInterpolationInputRange(props);\n  if (!sceneRange) return { opacity: 0 };\n  return {\n    opacity: position.interpolate({\n      inputRange: [sceneRange.first, scene.index, sceneRange.last],\n      outputRange: [0, 1, 0],\n      extrapolate: 'clamp',\n    }),\n  };\n}\n\nconst VISIBLE = { opacity: 1 };\nconst HIDDEN = { opacity: 0 };\n\n// Toggle visibility of header without fading\nfunction forBackgroundWithInactiveHidden({\n  navigation,\n  scene,\n}: SceneInterpolatorProps) {\n  return navigation.state.index === scene.index ? VISIBLE : HIDDEN;\n}\n\n// Translate the background with the card\nconst BACKGROUND_OFFSET = Dimensions.get('window').width;\n\nfunction forBackgroundWithTranslation(props: SceneInterpolatorProps) {\n  const { position, scene } = props;\n  const interpolate = getSceneIndicesForInterpolationInputRange(props);\n  if (!interpolate) return { opacity: 0 };\n  const { first, last } = interpolate;\n  const index = scene.index;\n  const offset = BACKGROUND_OFFSET;\n  const outputRange = [offset, 0, -offset];\n  return {\n    transform: [\n      {\n        translateX: position.interpolate({\n          inputRange: [first, index, last],\n          outputRange: I18nManager.isRTL ? outputRange.reverse() : outputRange,\n          extrapolate: 'clamp',\n        }),\n      },\n    ],\n  };\n}\n\n// Default to fade transition\nconst forBackground = forBackgroundWithInactiveHidden;\n\nexport default {\n  forLayout,\n  forLeft,\n  forLeftButton,\n  forLeftLabel,\n  forCenterFromLeft,\n  forCenter,\n  forRight,\n  forBackground,\n  forBackgroundWithInactiveHidden,\n  forBackgroundWithFade,\n  forBackgroundWithTranslation,\n};\n"]},"metadata":{},"sourceType":"module"}