{"ast":null,"code":"function getSceneIndicesForInterpolationInputRange(props) {\n  var scene = props.scene,\n      scenes = props.scenes;\n  var index = scene.index;\n  var lastSceneIndexInScenes = scenes.length - 1;\n  var isBack = !scenes[lastSceneIndexInScenes].isActive;\n\n  if (isBack) {\n    var currentSceneIndexInScenes = scenes.findIndex(function (item) {\n      return item === scene;\n    });\n    var targetSceneIndexInScenes = scenes.findIndex(function (item) {\n      return item.isActive;\n    });\n    var targetSceneIndex = scenes[targetSceneIndexInScenes].index;\n    var lastSceneIndex = scenes[lastSceneIndexInScenes].index;\n\n    if (index !== targetSceneIndex && currentSceneIndexInScenes === lastSceneIndexInScenes) {\n      return {\n        first: Math.min(targetSceneIndex, index - 1),\n        last: index + 1\n      };\n    } else if (index === targetSceneIndex && currentSceneIndexInScenes === targetSceneIndexInScenes) {\n      return {\n        first: index - 1,\n        last: Math.max(lastSceneIndex, index + 1)\n      };\n    } else if (index === targetSceneIndex || currentSceneIndexInScenes > targetSceneIndexInScenes) {\n      return null;\n    } else {\n      return {\n        first: index - 1,\n        last: index + 1\n      };\n    }\n  } else {\n    return {\n      first: index - 1,\n      last: index + 1\n    };\n  }\n}\n\nexport default getSceneIndicesForInterpolationInputRange;","map":{"version":3,"sources":["getSceneIndicesForInterpolationInputRange.tsx"],"names":["scene","scenes","props","index","lastSceneIndexInScenes","isBack","currentSceneIndexInScenes","item","targetSceneIndexInScenes","targetSceneIndex","lastSceneIndex","first","Math","last"],"mappings":"AAOA,SAAA,yCAAA,CAAA,KAAA,EAAiE;EAAA,IACvDA,KADuD,GACrCE,KADqC,CAAA,KAAA;EAAA,IAChDD,MADgD,GACrCC,KADqC,CAAA,MAAA;EAE/D,IAAMC,KAAK,GAAGH,KAAK,CAAnB,KAAA;EACA,IAAMI,sBAAsB,GAAGH,MAAM,CAANA,MAAAA,GAA/B,CAAA;EACA,IAAMI,MAAM,GAAG,CAACJ,MAAM,CAANA,sBAAM,CAANA,CAAhB,QAAA;;EAEA,IAAA,MAAA,EAAY;IACV,IAAMK,yBAAyB,GAAGL,MAAM,CAANA,SAAAA,CAAiB,UAAA,IAAA,EAAI;MAAA,OAAIM,IAAI,KAAR,KAAA;IAAvD,CAAkCN,CAAlC;IACA,IAAMO,wBAAwB,GAAGP,MAAM,CAANA,SAAAA,CAAiB,UAAA,IAAA,EAAI;MAAA,OAAIM,IAAI,CAAR,QAAA;IAAtD,CAAiCN,CAAjC;IACA,IAAMQ,gBAAgB,GAAGR,MAAM,CAANA,wBAAM,CAANA,CAAzB,KAAA;IACA,IAAMS,cAAc,GAAGT,MAAM,CAANA,sBAAM,CAANA,CAAvB,KAAA;;IAEA,IACEE,KAAK,KAALA,gBAAAA,IACAG,yBAAyB,KAF3B,sBAAA,EAGE;MACA,OAAO;QACLK,KAAK,EAAEC,IAAI,CAAJA,GAAAA,CAAAA,gBAAAA,EAA2BT,KAAK,GADlC,CACES,CADF;QAELC,IAAI,EAAEV,KAAK,GAFb;MAAO,CAAP;IAJF,CAAA,MAQO,IACLA,KAAK,KAALA,gBAAAA,IACAG,yBAAyB,KAFpB,wBAAA,EAGL;MACA,OAAO;QACLK,KAAK,EAAER,KAAK,GADP,CAAA;QAELU,IAAI,EAAED,IAAI,CAAJA,GAAAA,CAAAA,cAAAA,EAAyBT,KAAK,GAFtC,CAEQS;MAFD,CAAP;IAJK,CAAA,MAQA,IACLT,KAAK,KAALA,gBAAAA,IACAG,yBAAyB,GAFpB,wBAAA,EAGL;MACA,OAAA,IAAA;IAJK,CAAA,MAKA;MACL,OAAO;QAAEK,KAAK,EAAER,KAAK,GAAd,CAAA;QAAoBU,IAAI,EAAEV,KAAK,GAAtC;MAAO,CAAP;IAEH;EA9BD,CAAA,MA8BO;IACL,OAAO;MAAEQ,KAAK,EAAER,KAAK,GAAd,CAAA;MAAoBU,IAAI,EAAEV,KAAK,GAAtC;IAAO,CAAP;EAEH;AAED;;AAAA,eAAA,yCAAA","sourcesContent":["import { Scene } from '../types';\n\ntype Props = {\n  scene: Scene;\n  scenes: Scene[];\n};\n\nfunction getSceneIndicesForInterpolationInputRange(props: Props) {\n  const { scene, scenes } = props;\n  const index = scene.index;\n  const lastSceneIndexInScenes = scenes.length - 1;\n  const isBack = !scenes[lastSceneIndexInScenes].isActive;\n\n  if (isBack) {\n    const currentSceneIndexInScenes = scenes.findIndex(item => item === scene);\n    const targetSceneIndexInScenes = scenes.findIndex(item => item.isActive);\n    const targetSceneIndex = scenes[targetSceneIndexInScenes].index;\n    const lastSceneIndex = scenes[lastSceneIndexInScenes].index;\n\n    if (\n      index !== targetSceneIndex &&\n      currentSceneIndexInScenes === lastSceneIndexInScenes\n    ) {\n      return {\n        first: Math.min(targetSceneIndex, index - 1),\n        last: index + 1,\n      };\n    } else if (\n      index === targetSceneIndex &&\n      currentSceneIndexInScenes === targetSceneIndexInScenes\n    ) {\n      return {\n        first: index - 1,\n        last: Math.max(lastSceneIndex, index + 1),\n      };\n    } else if (\n      index === targetSceneIndex ||\n      currentSceneIndexInScenes > targetSceneIndexInScenes\n    ) {\n      return null;\n    } else {\n      return { first: index - 1, last: index + 1 };\n    }\n  } else {\n    return { first: index - 1, last: index + 1 };\n  }\n}\n\nexport default getSceneIndicesForInterpolationInputRange;\n"]},"metadata":{},"sourceType":"module"}